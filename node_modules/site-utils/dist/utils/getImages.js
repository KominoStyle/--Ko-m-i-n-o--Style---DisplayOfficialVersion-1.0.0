"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _GetImages_logConfig;
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetImages = void 0;
/**
 * Provides methods for getting Images from URLs and HTML elements.
 */
class GetImages {
    /**
    * Constructor of GetImages class.
    * @param loggerConfig - (Optional) The configuration for logging.
    */
    constructor(loggerConfig) {
        _GetImages_logConfig.set(this, {}
        /**
        * Constructor of GetImages class.
        * @param loggerConfig - (Optional) The configuration for logging.
        */
        );
        if (loggerConfig)
            __classPrivateFieldSet(this, _GetImages_logConfig, loggerConfig, "f");
    }
    /**
     * Finds all the image elements in the provided HTML elements.
     * @param elements - The HTML elements to search for images in.
     * @returns An array of HTMLImageElement instances.
     */
    findAllImages(elements) {
        const images = [];
        // function getAllAttributes(element: HTMLElement): Record<string, string> {
        //     const attributes = element.attributes
        //     const result: Record<string, string> = {}
        //     for (let i = 0;i < attributes.length;i++) {
        //         const attribute = attributes.item(i)
        //         if (attribute) {
        //             result[attribute.name] = attribute.value
        //         }
        //     }
        //     return result
        // }
        elements.forEach(container => {
            images.push(...container.querySelectorAll("img"));
            // images.forEach(image => {
            //     const allAttributes = getAllAttributes(image)
            //     console.log(allAttributes)
            // })
        });
        return images;
    }
    getImage(content, fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (fileName === undefined) {
                const imgDescriptors = yield this.getImageDescriptors(content);
                return imgDescriptors;
            }
            else {
                const imgSrces = yield this.getImageSrces(content);
                if (__classPrivateFieldGet(this, _GetImages_logConfig, "f").info)
                    console.info(imgSrces);
                return imgSrces;
            }
        });
    }
    /**
     * Extracts image source URLs and their corresponding names (if available) from an array of HTML elements.
     * @param content - An array of HTML elements to search for images.
     * @returns An array of `ImageDescriptor` objects.
     * @throws An error if the `src` attribute value is not found.
     */
    getImageDescriptors(content) {
        return __awaiter(this, void 0, void 0, function* () {
            const imges = this.findAllImages(content);
            let logCounter = 0;
            let namePlaceholderCounter = 1;
            const imgDescriptors = [];
            imges.forEach((element) => {
                var _a, _b, _c;
                let name;
                const lazyloading = element.getAttribute('loading');
                const getSrc = element.getAttribute('src');
                const getDataSrc = element.getAttribute('data-src');
                let hasSrc = getDataSrc || getSrc;
                if (hasSrc === null)
                    throw new Error(`Skipping: 'src' attribute value. Failed to find`);
                if (lazyloading && getDataSrc) {
                    hasSrc = getDataSrc;
                }
                try {
                    new URL(hasSrc);
                }
                catch (error) {
                    if (__classPrivateFieldGet(this, _GetImages_logConfig, "f").error)
                        console.error(`Invalid URL found: ${hasSrc}`);
                    return;
                }
                const attrData_Key = element.getAttribute('data-image-key');
                const attrData_Name = (_a = element.getAttribute('data-image-name')) === null || _a === void 0 ? void 0 : _a.replace(" ", "_");
                const attrAlt = (_b = element.getAttribute('alt')) === null || _b === void 0 ? void 0 : _b.replace(" ", "_");
                const checkThisAttr = (_c = attrData_Key !== null && attrData_Key !== void 0 ? attrData_Key : attrData_Name) !== null && _c !== void 0 ? _c : attrAlt;
                if (checkThisAttr === undefined) {
                    if (__classPrivateFieldGet(this, _GetImages_logConfig, "f").info)
                        console.info(`No possible filename found. New Name: Placeholder${namePlaceholderCounter}`);
                    name = `Placeholder${namePlaceholderCounter++}`;
                }
                else {
                    name = checkThisAttr;
                }
                if (imgDescriptors.find((value) => value.name === name)) {
                    if (__classPrivateFieldGet(this, _GetImages_logConfig, "f").duplicate)
                        logCounter++, console.warn(logCounter, `Skipping: "${name}". Already found`);
                    return;
                }
                imgDescriptors.push({ src: hasSrc, name });
                logCounter++;
                if (__classPrivateFieldGet(this, _GetImages_logConfig, "f").log)
                    console.log(logCounter, name);
            });
            return imgDescriptors;
        });
    }
    /**
     * Extracts unique image source URLs from an array of HTML elements.
     * @param content - An array of HTML elements to search for images.
     * @returns A `Set` of unique image source URLs.
     * @throws An error if the `src` attribute value is not found.
     */
    getImageSrces(content, getSrcFunc) {
        return __awaiter(this, void 0, void 0, function* () {
            const imges = this.findAllImages(content);
            let logCounter = 0;
            const imgSet = new Set();
            imges.forEach((element) => {
                const lazyloading = element.getAttribute('loading');
                const getSrc = element.getAttribute('src');
                const getDataSrc = element.getAttribute('data-src');
                let hasSrc = getDataSrc || getSrc;
                if (hasSrc === null)
                    throw new Error(`Skipping: 'src' attribute value. Failed to find`);
                if (lazyloading && getDataSrc) {
                    hasSrc = getDataSrc;
                }
                try {
                    new URL(hasSrc);
                }
                catch (error) {
                    if (__classPrivateFieldGet(this, _GetImages_logConfig, "f").error)
                        console.error(`Invalid URL found: ${hasSrc}`);
                    return;
                }
                if (imgSet.has(hasSrc)) {
                    if (__classPrivateFieldGet(this, _GetImages_logConfig, "f").duplicate)
                        logCounter++, console.warn(logCounter, `Skipping: 'src' attribute value. Already found`);
                    return;
                }
                imgSet.add(hasSrc);
                logCounter++;
                if (__classPrivateFieldGet(this, _GetImages_logConfig, "f").log)
                    console.log(logCounter, `${hasSrc}`);
            });
            return imgSet;
        });
    }
}
exports.GetImages = GetImages;
_GetImages_logConfig = new WeakMap();
