"use strict";
//* !♥Koͨmͧiͭnͥoͤ Style♥! just made it as a class
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MeasureTime = void 0;
class MeasureTime {
    measureAsync(process, expect, ...params) {
        return __awaiter(this, void 0, void 0, function* () {
            const start = this.now();
            yield process(...params);
            return this.elapsed(start, expect);
        });
    }
    measure(process, expect, ...params) {
        const start = this.now();
        process(...params);
        return this.elapsed(start, expect);
    }
    // Returns current time
    now() {
        return Date.now();
    }
    // Returns time elapsed since `beginning`
    // (and, optionally, prints the duration in seconds)
    elapsed(beginning, expect, log) {
        const duration = this.now() - beginning; //? this is for testing
        const formattedTime = this.formatTime(duration, expect);
        if (log)
            console.log(`${formattedTime}`);
        // return duration //? Origial???
        return formattedTime;
    }
    formatTime(duration, expect = {}) {
        var _a, _b, _c;
        if (duration < 0)
            throw new Error();
        if (expect.year && expect.week || expect.month && expect.week)
            throw new Error("Fuck You");
        const milliseconds = duration % 1000;
        const seconds = Math.floor((duration / 1000) % 60);
        const minutes = Math.floor((duration / 1000 / 60) % 60);
        const hours = Math.floor((duration / 1000 / 60 / 60) % 24);
        let days;
        const weeks = Math.floor(duration / 1000 / 60 / 60 / 24 / 7);
        let months = 0;
        let years = 0;
        switch (true) {
            case expect.week:
                days = Math.floor((duration / 1000 / 60 / 60 / 24) % 7);
                break;
            case expect.year && expect.month:
                days = Math.floor((duration / 1000 / 60 / 60 / 24) % 30.436875);
                months = Math.floor((duration / 1000 / 60 / 60 / 24 / 30.436875) % 12);
                years = Math.floor(duration / 1000 / 60 / 60 / 24 / 30.436875 / 12);
                break;
            case expect.year:
                days = Math.floor((duration / 1000 / 60 / 60 / 24) % 365.2425);
                years = Math.floor(duration / 1000 / 60 / 60 / 24 / 365.2425);
                break;
            case expect.month:
                days = Math.floor((duration / 1000 / 60 / 60 / 24) % 30.436875);
                months = Math.floor(duration / 1000 / 60 / 60 / 24 / 30.436875);
                break;
            default:
                days = Math.floor(duration / 1000 / 60 / 60 / 24);
                break;
        }
        const units = [
            { value: years, symbol: "y", expected: (_a = expect.year) !== null && _a !== void 0 ? _a : false, notAllowed: ["week"] },
            { value: months, symbol: "m", expected: (_b = expect.month) !== null && _b !== void 0 ? _b : false, notAllowed: ["week"] },
            { value: weeks, symbol: "w", expected: (_c = expect.week) !== null && _c !== void 0 ? _c : false, notAllowed: ["year", "month"] },
            { value: days, symbol: "d", expected: true, notAllowed: [] },
            { value: hours, symbol: "h", expected: true, notAllowed: [] },
            { value: minutes, symbol: "min", expected: true, notAllowed: [] },
            { value: seconds, symbol: "s", expected: true, notAllowed: [] },
            { value: milliseconds, symbol: "ms", expected: true, notAllowed: [] }
        ].filter(unit => unit.value > 0 && unit.expected && !unit.notAllowed.some(item => expect[item]));
        if (units.some(unit => unit.symbol === "h" || unit.symbol === "d" || unit.symbol === "y" || unit.symbol === "m" || unit.symbol === "w")) {
            if (units.some(unit => unit.symbol === "ms"))
                units.splice(units.findIndex(unit => unit.symbol === "ms"), 1);
        }
        return units.map((unit) => {
            return `${unit.value}${unit.symbol}`;
        }).join(" ");
    }
}
exports.MeasureTime = MeasureTime;
